Unix-Shell
==========
This is a simple Unix shell project, in which I implemented following things:
  1. a shell interface
  2. execution of built-in commands and external programs under the shell
  3. handling pipe and redirection under the shell
  4. handling job controls (switch jobs between foreground and background) under the shell

Specification

1. Introduction

  (1). When first running the program, it shows the current directory and waits for input, like this:
      [OS shell:/home/some_directory]$
  
  (2). The input command line is a character string. The OS shell should read in the input command line
      from the standard input stream (stdin in C) of the OS shell.

    Note: 
    
        assume that:
        
          1. An input command line has a maximum length of 255 characters.
          2. An input command line ends with a carriage return character ’\n’.
          3. There is neither leading nor trailing space characters in the input command line.
          4. A token is a series of characters without any space characters. Each token (or word) in the
            input command line is separated by at least one space character.
2. Internal commands

The OS Shell can support the following internal commands:

· Any other build-in commands, e.g., ls, mkdir, who, whoami, cp, mv, rm, rmdir, cal,
  chmod, pwd, etc, where I do not list all the commands, which does not mean that the OS shell
  can not process them. In fact, the OS shell should support most commands.
  
· cd: changes the current working directory to the directory supplied as argument. If there is no
  argument, you should print an error message.
  
· status: this command can print the status of the last command executed. Commands return
  0 as the indication of success, and any non-zero value to indicate the failure.
  
· history: The OS shell can record all the historical commands that have been executed
  before.
  
· exit: leaves the shell.

· Note that the OS shell are able to resolve the parameters of these commands as well. For
  example, ls –al.
  
· External Programs: The OS shell are able to execute any other external programs as well. For example, an
  executable program “hello” generated by gcc compiler can run in the OS shell correctly, e.g.,
  your run “./hello” in the OS shell.

3.1 Shell constructs (I/O Redirection and Pipes)

There are certain constructs the OS shell can to support.

redirection:  standard input is redirected using < ARG. This means that command receives

everything written in the file ARG, as it would be typed on the keyboard. Standard output is

redirected by using > ARG. You do not need to care about standard error.

pipes:  two (or more) commands can be connected together using the syntax COMMAND1 |
COMMAND2. This connects the output of COMMAND1 to the input of COMMAND2.

Note: For simplicity, the OS shell only need to support either input redirection or output redirection
and you don’t need to consider them both at the same shell.

3.2 Job control

The OS shell can support basic job controls of a Unix Shell.

Put a foreground job to background:  the user can type “Ctrl+z” to temporarily suspend a running
front-ground command, the shell shall give the user some hints about the suspended command.

Note:
  Specifically, the OS shell can give the job number of the suspended command, e.g., “<JobNum>
  Suspended”. Then, the user can use the command “bg <JobNum>” to put the suspended job to
  background, where <JobNum> is the job number assigned by the OS shell.

Put a background job to foreground:  the user can type “command &” to run a command (job) in
background (Note that this command shall run relatively a long time, e.g., “sleep 1000&”). The
OS shell can also give a hint about the background job information (i.e., the job number) so that the
user can seize the control the job later. Before the background job end, the user can put it to the
foreground by using the command “fg <JobNum>” and then the background shall run in
foreground.

List all the running jobs:  The user can type “jobs” to display all the current running jobs in your
system as well as the status of the jobs.



How to use: 
  1. complie under Linux/Unix system command line: gcc -o OSshell OSshell.c
  2. run under command line: ./OSshell
